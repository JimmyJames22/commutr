{"ast":null,"code":"import { createContext, useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  var ctx = /*#__PURE__*/createContext(_extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    ctx.displayName = name;\n  }\n\n  return ctx;\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };","map":{"version":3,"sources":["/Users/gunner/Documents/GitHub/commutr-main/commutr/frontend/node_modules/@reach/descendants/dist/reach-descendants.esm.js"],"names":["createContext","useContext","useState","useCallback","createElement","useMemo","useForceUpdate","useIsomorphicLayoutEffect","noop","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","arguments","prototype","hasOwnProperty","call","apply","_excluded","createDescendantContext","name","initialValue","descendants","ctx","registerDescendant","unregisterDescendant","process","env","NODE_ENV","displayName","useDescendant","descendant","context","indexProp","forceUpdate","_React$useContext","index","findIndex","item","element","concat","values","useDescendantsInit","useDescendants","DescendantProvider","_ref","Ctx","children","items","set","_ref2","explicitIndex","rest","newItems","sort","a","b","find","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","newItem","slice","map","filter","Provider","value","useDescendantKeyDown","options","_React$useContext2","callback","currentIndex","_options$key","_options$orientation","orientation","_options$rotate","rotate","_options$rtl","rtl","handleKeyDown","event","includes","selectableDescendants","selectableIndex","getNextOption","atBottom","getLastOption","getFirstOption","getPreviousOption","atTop","preventDefault","next","prev","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","first","nextOrLast","last"],"mappings":"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","sourcesContent":["import { createContext, useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar _excluded = [\"element\", \"index\"];\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  var ctx = /*#__PURE__*/createContext(_extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    ctx.displayName = name;\n  }\n\n  return ctx;\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants so that\n  // everything is up-to-date before the user interacts with a collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      unregisterDescendant(descendant.element);\n    };\n  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        return [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]).sort(function (a, b) {\n          return a.index - b.index;\n        });\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [_extends({}, rest, {\n          element: element,\n          index: 0\n        })];\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // We need some options for any of this to work!\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    var selectableIndex = selectableDescendants.findIndex(function (descendant) {\n      return descendant.index === currentIndex;\n    });\n\n    function getNextOption() {\n      var atBottom = index === getLastOption().index;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === getFirstOption().index;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };\n"]},"metadata":{},"sourceType":"module"}